# Продвинутое использование JWT-токенов

'''
СОВЕТ ПРЕПОДАВАТЕЛЮ: для работы на уроке вам и студентам понадобится проект
с занятия "Воркшоп. PostgreSQL и SQLModel". Предупредите студентов об этом
заранее, перед занятием. В начале занятия убедитесь, что у всех студентов
сейчас есть доступ к данному проекту.
'''

# Повторение основ работы с аутентификацией и авторизацией

'''
В предыдущем семестре, при знакомстве с backend-разработкой, мы работали
с регистрацией, авторизацией и аутентификацией пользователей.
Как вы помните, мы использовали JWT-токены, которые хорошо работают в FastAPI. 
И сегодня мы вспомним пройденные ранее вещи о JWT-токенах, а также
поработаем с новой информацией. Важно, что мы не будем реализовывать весь проект
с нуля, а воспользуемся наработками с прошлых занятий. 
Конкретно сегодня мы будем работать с проектом, который закончили делать 
на занятии "Воркшоп. PostgreSQL и SQLModel". 

Итак, сейчас повторим основные вещи про авторизаций, аутентификацию
и JWT-токены. Этот материал у нас уже был в предыдущем семестре, мы просто
освежим его в своей памяти.

Аутентификация - процесс проверки подлинности пользователя или системы,
направленный на подтверждение их права доступа к определенными ресурсам или данным.
Например, проверка подлинности пользователя путем сравнения введенных логина и пароля
с паролем, сохранным в БД пользовательских логинов.

Авторизация - предоставление клиенту прав на выполнение определенных действий,
а также проверка прав при выполнении этих действий.
Например, просто пользователей на может получить доступ ко всем данным других пользователей,
а админ - может.

Когда пользователь на сайте вводит логин и пароль, то после успешной проверки сервер
выдает пользователю специальный токен доступа или просто токен.

Токен - зашифрованная строка символов, обеспечивающая право пользователя или приложения
на выполнения определенных действий с защищенными ресурсами. Является своего рода "пропуском",
который предъявляется серверу, например, при каждом обращении к API.

Также мы помним, что в современной разработке для безопасного 
обмена токенами между клиентом и сервером существует специальный протокол под названием OAuth2.

OAuth2 – протокол авторизации, позволяющий приложениям получать ограниченный доступ
к ресурсам пользователя на другом сервисе без необходимости передачи его учетных данных.

OAuth2 позволяет:
- Входить по логину и паролю, получая специальный access token
- Не хранить пароль на стороне клиента
- Контролировать время жизни и область действия токена

Мы также помним, что одним из наиболее популярных видов токенов доступа на сегодняшний день
является JWT-токен.

JWT (JSON Web Token) - стандарт для создания токенов доступа, основанный на формате 
JSON. Используется для аутентификации и авторизации в веб-приложениях.
Пример как выглядит JWT-токен
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG
4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

Завершим повторение общей схемой того, как клиент и сервер взаимодействуют через JWT-токены.

Как клиент и сервер взаимодействуют с использование JWT-токенов
1) Клиент запрашивает доступ к ресурсу, отправляя учетные данные
2) Сервер получает учетные данные и если они действительны, то генерирует JWT-токен и 
отправляет его клиенту
3) При генерации JWT-токена сервер ставит подпись с помощью секретного ключа, который
хранится только на стороне сервера
4) Клиент сохраняет JWT-токен на своей стороне и добавляет его в заголовок каждого 
последующего HTTP-запроса
5) Сервер при получении нового запроса проверяет JWT-токен
'''

# -----------------------------------------------------------------------------------------

# Настройка секретного ключа

'''
Сейчас мы будем настраивать секретный ключ (SECRET_KEY) для нашего проекта, чтобы выдаваемые
токены была стабильными и не ломались после перезапуска сервера.

Помним, что JWT-токен "подписывается" секретным ключом для обеспечения безопасности при передаче данных.
Если секретный ключ поменяется - все равнее выданные токены станут недействительны.
Поэтому мы будем хранить один и тот же ключ между перезапусками приложения.
В предыдущем семестре мы хранили секретный ключ прямо в коде, что не очень хорошо с точки зрения 
безопасности. Сейчас мы знаем про .env-файлы и сегодня мы сохраним ключ именно туда.

Создадим .env-файл в корне нашего проекта и напишем там строку:
'''

# .env

SECRET_KEY=...

'''
Само значение ключа мы сгенерируем знакомы с предыдущего семестра способом - через встроенный
модуль secrets. В отдельном файле или интерактивной среде импортируем secrets и с помощью
функции token_hex() сгенерируем себе ключ:
'''

# В отдельном файле или интерактивной среде

from secrets import token_hex

print(token_hex(32))

'''
Скопируем полученный ключ и сохраним к себе в .env-файл:
'''

# .env

SECRET_KEY=f9fce53031123570ce2597a756451c42d0cfc4b1bde0fda62301ee476a936168

'''
СОВЕТ ПРЕПОДАВАТЕЛЮ: убедитесь, что все студенты создали секретный ключ и сохранили
его в файле .env.
'''

# -----------------------------------------------------------------------------------------

# Создание файла конфигурации

'''
Выше мы сохранили секретный ключ в .env-файл. Теперь создадим файл с конфигурацией нашего проекта.
Ранее на курсе мы научились работать с модулем pydantic-settings, его и будем использовать.
Для начала убедимся, что он установлен в виртуальном окружении нашего проекта. 

В терминале:

pip install pydantic-settings

Далее внутри папки app/ создадим папку core/, где создадим файл config.py, именно там будем
прописывать конфигурацию нашего проекта.

СОВЕТ ПРЕПОДАВАТЕЛЮ: убедитесь, что все студенты создали папку core/ 
и файл config.py внутри этой папки.

Внутри файла config.py напишем минимальный код, где создается класс Settings со следующими полями:
- model_config - настройка поведения pydantic-settings
- SECRET_KEY - строка с секретным ключом
- ACCESS_TOKEN_EXPIRE_MINUTES - время жизни токена в минутах

СОВЕТ ПРЕПОДАВАТЕЛЮ: подобный код вы уже писали со студентами на уроке "Конфигурация и настройка проекта".
Делайте отсылки на этот урок и старайтесь задействовать студентов при написании данного кода.
'''

# app/core/config.py

from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=".env",
        env_ignore_empty=True,
        extra="ignore"
    )

    SECRET_KEY: str
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

settings = Settings()

'''
Давайте убедимся, что секретный ключ действительно загружается в программу, а
а поля SECRET_KEY и ACCESS_TOKEN_EXPIRE_MINUTES доступны для чтения.
'''

# В терминале или интерактивной среде:

from app.core.config import settings

print(f'Секретный ключ загружен: {settings.SECRET_KEY}')
print(f'Время жизни токена: {settings.ACCESS_TOKEN_EXPIRE_MINUTES}')

'''
При запуске видим, что значения переменных успешно подтягиваются в программу.
'''

# -----------------------------------------------------------------------------------------

# Создание функций для работы с токенами и паролями

'''
Чуть ранее мы реализовали файл конфигурации нашего проекта. Через него мы будем обращаться
к переменным SECRET_KEY и ACCESS_TOKEN_EXPIRE_MINUTES, необходимым для работы с токенами
и паролями. В предыдущем семестре для такой логики мы создавали отдельный файл - 
сейчас поступим точно также. В папке core/ создадим файл security.py.

СОВЕТ ПРЕПОДАВАТЕЛЮ: убедитесь, что все студенты создали файл security.py 
внутри папки core/.

Перед написанием кода в файле security.py, установим необходимые библиотеки для работы
с JWT-токенами и шифрованием паролей. В прошлом семестре мы использовали библиотеки pyjwt
и pwdlib, установим их:

В терминале:

pip install pyjwt "pwdlib[argon2]"

Необходимые библиотеки установлены, теперь зафиксируем, что напишем внутри файла security.py:
- переменная ALGORITHM для хранения названия алгоритма шифрования
- функция create_access_token() для создания токена доступа
- функция get_password_hash() для получения хэша переданного пароля
- функция verify_password() для проверки введенного пароля
'''

# app/core/security.py

# подключаем инструменты для работы со временем действия токена доступа
from datetime import datetime, timedelta, timezone
# подключаем тип Any, чтобы указать, что ID пользователя может прийти не только в виде строки
from typing import Any

# импортируем инструменты для работы с хэшированием
import jwt
from pwdlib import PasswordHash
from pwdlib.hashers.argon2 import Argon2Hasher
from pwdlib.hashers.bcrypt import BcryptHasher

# импортируем объект с настройками конфигурации проекта
from app.core.config import settings

ALGORITHM = "HS256"

# указываем стратегию работы с хэшами - сначала будет работать Argon2Hasher,
# но если есть старые хэши, сделанные, например, через BcryptHasher - они тоже будут работать
# это полезно при миграции с одного алгоритма хэширования на другой, 
# чтобы старые хэши не ломались (нередкая практика в реальных проектах)

password_hash = PasswordHash(
    (
        Argon2Hasher(),
        BcryptHasher()
    )
)


# subject - идентификатор пользователя (может быть UUID, int, str, поэтому указываем | Any)
# expires_delta - время жизни токена
def create_access_token(subject: str | Any, expires_delta: timedelta) -> str:
    # вычисляем момент, когда токен перестанет работать
    # используем UTC-время, чтобы не было проблемы с часовыми поясами
    expire = datetime.now(timezone.utc) + expires_delta

    # формируем полезную нагрузку токена
    payload = {
        # по стандарту JWT название "sub" часто используют как "кому принадлежит токен"
        "sub": str(subject),
        # PyJWT умеет работать с datetime и сам преобразует его
        "exp": expire
    }

    # подписываем токен секретным ключом, чтобы клиент не мог подделать содержимое payload
    token = jwt.encode(
        payload=payload,            # данные токена
        key=settings.SECRET_KEY,    # секретный ключ
        algorithm=ALGORITHM         # алгоритм подписи
    )

    return token


# получить хэш пароля
def get_password_hash(password: str) -> str:
    return password_hash.hash(password)


# проверка пароля и обновление хэша при необходимости
def verify_password(plain_password: str, hashed_password: str) -> tuple[bool, str | None]:
    # проверка валидности пароля (False, True) 
    # и нужно ли обновлять хэш для надежности (None, "<новый_хэш>")
    verified, updated_hash = password_hash.verify_and_update(
        plain_password,
        hashed_password
    )
    return verified, updated_hash

'''
Еще раз обращаю ваше внимание, что в этот раз мы используем 2 инструмента для генерации хэша -
Argon2Hasher и BcryptHasher. Это может показаться избыточным, но, как мы уже говорили,
в реальных проектах может возникнуть необходимость миграции с одного алгоритма хэширования
на другой. При этом старые хэши, хранящиеся в БД, должны быть валидны, иначе пользователи
не смогут войти в свои учетные записи. Чтобы BcryptHasher у нас тоже работал, установим его:

В терминале:

pip install pwdlib[bcrypt]
'''

# -----------------------------------------------------------------------------------------

# Первичное внедрение JWT-авторизации в проект

'''
Для корректной работы с JWT-авторизацией наша программа должна уметь:
- Получать пользователя по username
- Сравнивать введенный пароль с тем, что хранится в БД
Мы знаем, что в БД нельзя хранить пароль в открытом виде, поэтому там хранится хэш пароля.

Таким образом, нам нужно модифицировать модели в файле app/models/users.py, добавив
в класс User поле hashed_password, а в модель UserCreate - поле password:
'''

# app/models/users.py

...
class UserCreate(UserBase):
    password: str = Field(min_length=8, max_length=128)


...
class User(UserBase, table=True):
    __tablename__ = "users"
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    hashed_password: str
    items: list["Item"] = Relationship(
        back_populates="user",
        passive_deletes="all"
    )

'''
С моделями разобрались, теперь отредактируем слой репозитория. Пойдем в файл app/repositories/users.py
и модифицируем функцию create_user():
'''

# app/repositories/users.py

...
# добавляем импорт функции для получения хэша
from app.core.security import get_password_hash

...
async def create_user(session: AsyncSession, user_data: UserCreate) -> User:
    # получаем хэш из переданного пароля
    hashed_password = get_password_hash(user_data.password)
    # создаем пользователя - берем все, кроме password
    data = user_data.model_dump(exclude={"password"})
    new_user = User(**data, hashed_password=hashed_password)
    session.add(new_user)
    await session.commit()
    await session.refresh(new_user)
    return new_user

'''
Осталось протестировать создание пользователя с учетом всех обновлений.
Если мы запустим приложение и попробуем создать пользователя через эндпоинт POST /users/,
то увидим ошибку в терминале: "столбец "hashed_password" в таблице "users" не существует".

Делаем вывод - нужно создать и выполнить миграцию, т.к. мы изменили структуру класса User,
добавив поле hashed_password. Создадим и применим новую миграцию:

В терминале:

alembic revision --autogenerate -m "add hashed_password to users"
alembic upgrade head

И снова беда - при выполнении миграции появилась ошибка:
"столбец "hashed_password" отношения "users" содержит значения NULL".
Оно и логично - для существующих пользователей, у которых нет пароля, нет и хэша,
а пустым этот столбец быть не может. Чтобы исправить эту проблему, мы откроем файл миграции
..._add_hashed_password_to_users.py и подправим его следующим образом:
1) Сначала для колонки hashed_password сделаем nullable=True, чтобы PostgreSQL разрешил
хранить NULL. Это временная мера, не переживайте.
2) Для существующих пользователей заполним столбец hashed_password любым валидным хэшем,
сгенерируем его ходу дела.
3) В конце для колонки hashed_password сделаем nullable=False, как и должно быть.

СОВЕТ ПРЕПОДАВАТЕЛЮ: в качестве хэша-заполнителя можете взять любой хэш, созданный
через Argon2Hasher(). Например, вот: "$argon2id$v=19$m=65536,t=3,p=4$MjQyZWE1MzBjYjJlZTI0Yw$YTU4NGM5ZTZmYjE2NzZlZjY0ZWY3ZGRkY2U2OWFjNjk"
'''

# ..._add_hashed_password_to_users.py
...
HASH_EXAMPLE = "$argon2id$v=19$m=65536,t=3,p=4$MjQyZWE1MzBjYjJlZTI0Yw$YTU4NGM5ZTZmYjE2NzZlZjY0ZWY3ZGRkY2U2OWFjNjk"

def upgrade() -> None:
    # для колонки hashed_password сделаем nullable=True
    op.add_column('users', sa.Column('hashed_password', sqlmodel.sql.sqltypes.AutoString(), nullable=True))

    # заполняем все существующие строки, где hashed_password равен NULL
    op.execute(f"UPDATE users SET hashed_password = '{HASH_EXAMPLE}' WHERE hashed_password IS NULL")

    # делаем hashed_password снова nullable=False
    op.alter_column("users", "hashed_password", nullable=False)

'''
Файл миграции отредактирован, попробуем снова применить миграцию.

В терминале:
alembic upgrade head

Миграция сработала! Если мы сейчас зайдем в DBeaver, то в таблице users увидим новый столбец 
hashed_password. И для каждого пользователя проставился указнный нами хэш.

СОВЕТ ПРЕПОДАВАТЕЛЮ: убедитесь, что у всех студентов сработала миграция и таблице
users появился столбец hashed_password.

Попробуем снова создать нового пользователя через эндпоинт POST /users.
Теперь все получается! Мы можем зайти в DBeaver и в таблице users увидеть нового пользователя
и сгенерированный для него хэш! 

На этом мы пока что закончим. На следующем занятии мы продолжим внедрение
JWT-авторизации в наш проект!
'''